#!/usr/bin/env python3
# IGT : A Basic Information Gathering Toolkit
# Developer: Anhar Hussan
# Version: 1

import os
import json
import random
import asyncio
from datetime import datetime
from pathlib import Path
import string
import re

import aiohttp
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn, TimeElapsedColumn, TimeRemainingColumn
from rich.table import Table

# --- Configuration ---
PLT_JSON = "plt.json"
RESULTS_DIR = Path("results")
RESULTS_DIR.mkdir(exist_ok=True)
ERROR_LOG = RESULTS_DIR / "errors.log"
PLATFORMS_ALLOWED = [
    "facebook", "instagram", "twitter", "x", "snapchat", "telegram", "tiktok", "threads"
]
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Linux; Android 14; Mobile; rv:109.0) Gecko/112.0 Firefox/112.0",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36"
]
DEFAULT_CONCURRENCY = 50  # You can increase/decrease this for more/less speed

console = Console()

# --- Utils ---
def load_platforms():
    if not Path(PLT_JSON).exists():
        console.print(f"[red][!] {PLT_JSON} not found. Please provide the file.[/red]")
        exit(1)
    with open(PLT_JSON, "r", encoding="utf-8") as f:
        data = json.load(f)
        platforms = []
        for p in data:
            name = p.get("name", "").strip().lower()
            if name in PLATFORMS_ALLOWED:
                if name == "x":
                    name = "twitter"
                platforms.append({
                    "name": name,
                    "url": p.get("url"),
                    "validation": p.get("validation", {}),
                })
        if not platforms:
            console.print("[red][!] No valid platforms found in plt.json.[/red]")
            exit(1)
        return platforms

def html_escape(text):
    return (text.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;"))

def save_html(username, results, stats):
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    fname = RESULTS_DIR / f"{username}_scan_{timestamp}.html"
    found_rows = [r for r in results if r['found']]
    not_found_rows = [r for r in results if not r['found']]

    # Chart.js data for pie chart
    chart_data = f"""
    const data = {{
      labels: ['FOUND', 'Not Found'],
      datasets: [{{
        data: [{len(found_rows)}, {len(not_found_rows)}],
        backgroundColor: ['#43aa8b', '#d3d3d3'],
      }}]
    }};
    """

    with open(fname, "w", encoding="utf-8") as f:
        f.write(f"""<!DOCTYPE html>
<html lang="en"><head>
<meta charset="UTF-8">
<title>IGT Social Results for {html_escape(username)}</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
body {{ font-family: 'Segoe UI', Arial, sans-serif; margin:2em; background:#fafbfc; }}
h1 {{ color:#1d3557; margin-bottom:0.5em; }}
table {{ border-collapse:collapse; width:100%; background:white; box-shadow:0 2px 10px #0001; }}
th,td {{ border:1px solid #dee2e6; padding:10px; text-align:left; }}
th {{ background:#457b9d; color:#fff; }}
tr:nth-child(even) {{ background:#f5f6fa; }}
a {{ color:#1976d2; word-break:break-all; }}
.status-ok {{ color:green; font-weight:bold; }}
.status-fail {{ color:#888; }}
.stats-block {{
  margin: 2em 0 2em 0; background: #fff; padding: 1em 2em; border-radius: 12px; box-shadow:0 2px 10px #0001;
}}
</style>
</head><body>
<h1>IGT Social Scan for <span style="color:#457b9d">{html_escape(username)}</span></h1>
<p>Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>

<div class="stats-block">
  <h2>Summary</h2>
  <ul>
    <li><b>Total platforms:</b> {stats['platforms']}</li>
    <li><b>Total username variations:</b> {stats['variations']}</li>
    <li><b>Total checks:</b> {len(results)}</li>
    <li><b>Profiles found:</b> {len(found_rows)}</li>
    <li><b>Profiles not found:</b> {len(not_found_rows)}</li>
    <li><b>Scan duration:</b> {stats['duration']} seconds</li>
  </ul>
  <canvas id="foundChart" width="320" height="120"></canvas>
</div>

<table>
<tr>
<th>Platform</th>
<th>Variation</th>
<th>Status</th>
<th>Link</th>
</tr>
""")
        for row in results:
            plat = html_escape(row['platform'].capitalize())
            var = html_escape(row['variant'])
            status = '<span class="status-ok">FOUND</span>' if row['found'] else '<span class="status-fail">Not Found</span>'
            link = f'<a href="{html_escape(row["url"])}" target="_blank">{html_escape(row["url"])}</a>'
            f.write(f"<tr><td>{plat}</td><td>{var}</td><td>{status}</td><td>{link}</td></tr>\n")
        f.write(f"""
</table>
<footer style="margin-top:2em;color:#888;">Generated by IGT Toolkit</footer>
<script>
{chart_data}
const config = {{
  type: 'pie',
  data: data,
}};
new Chart(document.getElementById('foundChart'), config);
</script>
</body></html>
""")
    console.print(f"[green][+] HTML result saved to {fname}[/green]")

def log_error(msg):
    with open(ERROR_LOG, "a", encoding="utf-8") as f:
        f.write(f"{datetime.now().isoformat()} | {msg}\n")

# --- Username Variation Generator ---
def leetify(s):
    leet_map = {'a':'4','e':'3','i':'1','o':'0','s':'5','t':'7'}
    return ''.join(leet_map.get(c,c) for c in s)

def separators():
    return ['', '.', '_', '-', '']

def generate_variations(username, min_variations=100):
    """Generate 100+ username variations with prefixes, suffixes, leetspeak, numbers, etc."""
    base = username.lower()
    variations = set()
    # 1. Simple
    variations.add(base)
    variations.add(base.capitalize())
    # 2. Prefixes/Suffixes
    pre = ['the', 'real', 'official', 'mr', 'ms', 'iam', 'not', 'fake', 'its', 'just', 'super', 'ultra', 'pro', 'x', '1', '0']
    suf = ['official', 'real', '1', '123', '2024', '2025', 'hq', 'tv', 'pro', 'io', 'x', 'dev', 'bot', 'admin']
    # 3. Leet
    variations.add(leetify(base))
    # 4. Year/Numbers
    years = ['2024', '2025', '2000', '1999']
    # 5. Separators
    for p in pre:
        for s in suf:
            for sep1 in separators():
                for sep2 in separators():
                    v = f"{p}{sep1}{base}{sep2}{s}"
                    variations.add(v)
    # 6. With years, leet, etc.
    for y in years:
        variations.add(f"{base}{y}")
        variations.add(f"{y}{base}")
    # 7. Some random numbers
    for i in range(1, 25):
        variations.add(f"{base}{i}")
        variations.add(f"{base}_{i}")
        variations.add(f"{base}{str(i).zfill(2)}")
    # 8. Leet with suffix
    variations.add(leetify(base) + "1")
    variations.add(leetify(base) + "x")
    # 9. First/last letter combos
    if len(base) >= 2:
        variations.add(base[0]+base[-1])
        variations.add(base[:2]+base[-2:])
    # 10. Mix case
    variations.add(base.upper())
    # 11. Insert underscores/dots
    for i in range(1, len(base)):
        variations.add(base[:i] + '_' + base[i:])
        variations.add(base[:i] + '.' + base[i:])
    # 12. Reverse
    variations.add(base[::-1])
    # 13. Remove vowels
    vowel_rm = re.sub(r'[aeiou]', '', base)
    if vowel_rm:
        variations.add(vowel_rm)
    # 14. Add random digit at random position
    for i in range(10):
        idx = random.randint(0, len(base))
        variations.add(base[:idx] + str(i) + base[idx:])
    # 15. Shortened/cut
    if len(base) > 3:
        variations.add(base[:3])
        variations.add(base[:4])
    # 16. Add random suffixes
    for s in suf:
        variations.add(f"{base}{s}")
    # 17. Add double letters
    variations.add(base + base[-1]*2)
    # 18. Add 'official' in front
    variations.add('official' + base)
    # 19. Add 'the' at the end
    variations.add(base + 'the')
    # 20. Add "_dev", "_admin", etc.
    for s in ['dev', 'admin', 'test', 'bot', 'team']:
        variations.add(f"{base}_{s}")
    # 21. Remove last char
    if len(base) > 1:
        variations.add(base[:-1])
    # Ensure enough
    variations = list(variations)
    random.shuffle(variations)
    while len(variations) < min_variations:
        # Add random combos to reach min
        prefix = random.choice(pre)
        suffix = random.choice(suf)
        sep = random.choice(['', '_', '.', '-'])
        v = f"{prefix}{sep}{base}{sep}{suffix}{random.randint(0,999)}"
        variations.append(v)
    # Limit to max (e.g. 120)
    return variations[:max(120, min_variations)]

# --- Scanning ---
async def fetch_profile(session, url, headers):
    tries = 2
    for _ in range(tries):
        try:
            async with session.get(url, headers=headers, timeout=20, ssl=False) as resp:
                text = await resp.text(errors="replace")
                return resp.status, text
        except Exception as e:
            await asyncio.sleep(1)
    return None, None

async def scan_username_on_platform(session, plat, username_variation, semaphore):
    url = plat["url"].format(username_variation)
    headers = {"User-Agent": random.choice(USER_AGENTS)}
    async with semaphore:
        status, text = await fetch_profile(session, url, headers)
    absent = plat["validation"].get("text_absent", "") or plat["validation"].get("absent", "")
    found = False
    try:
        if status == 200 and absent:
            if absent.lower() not in text.lower():
                found = True
        elif status == 200 and not absent:
            found = True
    except Exception as e:
        log_error(f"Error parsing {url}: {e}")
    return {
        "platform": plat["name"],
        "variant": username_variation,
        "found": found,
        "url": url
    }

async def scan_all(username, platforms, variations, concurrency):
    results = []
    errors = []
    semaphore = asyncio.Semaphore(concurrency)
    total = len(platforms) * len(variations)
    task_args = []
    for plat in platforms:
        for var in variations:
            task_args.append((plat, var))
    # Progress bar
    with Progress(
            SpinnerColumn(),
            "[progress.description]{task.description}",
            BarColumn(),
            "[progress.percentage]{task.percentage:>3.0f}%",
            "â€¢",
            TimeElapsedColumn(),
            "â€¢",
            TimeRemainingColumn(),
            console=console,
            transient=True,
    ) as progress:
        task = progress.add_task("[cyan]Scanning...", total=total)
        async with aiohttp.ClientSession() as session:
            tasks = [
                scan_username_on_platform(session, plat, var, semaphore)
                for plat, var in task_args
            ]
            for coro in asyncio.as_completed(tasks):
                res = await coro
                results.append(res)
                progress.update(task, advance=1)
    return results

def print_summary_table(results):
    found = [r for r in results if r["found"]]
    notfound = [r for r in results if not r["found"]]
    table = Table(title="Scan Summary", show_lines=True)
    table.add_column("Platform", style="cyan", no_wrap=True)
    table.add_column("Found", justify="right", style="green")
    table.add_column("Not Found", justify="right", style="grey50")
    platforms = set(r["platform"] for r in results)
    for plat in sorted(platforms):
        found_n = sum(1 for r in found if r["platform"] == plat)
        notfound_n = sum(1 for r in notfound if r["platform"] == plat)
        table.add_row(plat.capitalize(), str(found_n), str(notfound_n))
    console.print(table)

def main():
    console.print(
    "[bold cyan]"
    "â–œâ–˜â–žâ–€â––â–€â–›â–˜     â–žâ–€â––      â–—    â–œ  â–žâ–€â––            â–—\n"
    "â– â–Œâ–„â–– â–Œ  â–„â–„â–– â–šâ–„ â–žâ–€â––â–žâ–€â––â–„ â–â–€â––â–  â–šâ–„ â–žâ–€â––â–â–€â––â–›â–€â––â–›â–€â––â–„ â–›â–€â––â–žâ–€â–Œ\n"
    "â– â–Œ â–Œ â–Œ      â–– â–Œâ–Œ â–Œâ–Œ â––â– â–žâ–€â–Œâ–  â–– â–Œâ–Œ â––â–žâ–€â–Œâ–Œ â–Œâ–Œ â–Œâ– â–Œ â–Œâ–šâ–„â–Œ\n"
    "â–€â–˜â–â–€  â–˜      â–â–€ â–â–€ â–â–€ â–€â–˜â–â–€â–˜ â–˜ â–â–€ â–â–€ â–â–€â–˜â–˜ â–˜â–˜ â–˜â–€â–˜â–˜ â–˜â–—â–„â–˜"
    "[/bold cyan]"
)
    console.print("[bold cyan]IGT: A Basic Information Gathering Toolkit v1[/bold cyan]")
    platforms = load_platforms()
    username = console.input("[green]Enter the username to scan:[/green] ").strip()
    if not username:
        console.print("[red]No username provided![/red]")
        return
    concurrency = DEFAULT_CONCURRENCY
    console.print(f"[grey58]Generating 100+ smart username variations...[/grey58]")
    variations = generate_variations(username, 100)
    console.print(f"Scanning {username} across {len(platforms)} platforms and {len(variations)} variations (~{len(platforms)*len(variations)} checks)...\n")
    start = datetime.now()
    results = asyncio.run(scan_all(username, platforms, variations, concurrency))
    duration = (datetime.now() - start).total_seconds()
    save_html(username, results, stats={
        "platforms": len(platforms),
        "variations": len(variations),
        "duration": f"{duration:.1f}"
    })
    found_count = sum(r["found"] for r in results)
    print_summary_table(results)
    console.print(f"[bold green]{found_count} found[/bold green] / {len(results)} checked in {duration:.1f} seconds.")

if __name__ == "__main__":
    main()